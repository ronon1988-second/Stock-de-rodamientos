/**
 * @fileoverview Firestore Security Rules for Inventory Management App
 *
 * Core Philosophy:
 * This ruleset enforces a role-based access control model. Admins have full access, editors have broad read/write access,
 * and unauthenticated users have no access except public data. Data validation is relaxed in favor of rapid prototyping.
 *
 * Data Structure:
 * - /inventory/{itemId}: Inventory items.
 * - /sectors/{sectorId}: Plant sectors.
 * - /sectors/{sectorId}/machines/{machineId}: Machines within sectors.
 * - /machineAssignments/{assignmentId}: Assignments of items to machines.
 * - /usageLog/{logId}: Usage logs for inventory items.
 * - /users/{userId}: User profiles.
 * - /roles/{userId}: User roles (admin, editor, etc.).
 *
 * Key Security Decisions:
 * - Role-based access control: Admins and editors have different levels of access.
 * - No user listing: Listing users is generally disallowed.
 * - Default deny: Any access not explicitly allowed is denied.
 * - Public read for inventory data: Inventory data is publicly readable, but writes are restricted to authenticated users.
 *
 * Denormalization for Authorization:
 * - User roles are stored in a separate /roles/{userId} document to simplify authorization checks.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's ID matches the provided user ID.
     * @param {string} userId The user ID to check against.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user's role is 'admin'.
     * @return {boolean} True if the user is an admin, false otherwise.
     */
    function isAdmin() {
      return get(/databases/$(database)/documents/roles/$(request.auth.uid)).data.role == 'admin';
    }

    /**
     * @description Checks if the authenticated user's role is 'editor'.
     * @return {boolean} True if the user is an editor, false otherwise.
     */
    function isEditor() {
      return get(/databases/$(database)/documents/roles/$(request.auth.uid)).data.role == 'editor';
    }

    /**
     * @description Checks if the authenticated user is an existing owner.
     * @param {string} userId The user ID to check against.
     * @return {boolean} True if the user is the owner and the resource exists.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Rules for the /inventory collection.
     * @path /inventory/{itemId}
     * @allow (get, list) Public read access.
     * @allow (create) Only admins and editors can create new items.
     * @allow (update, delete) Only admins and editors can update or delete items.
     * @deny User attempts to create an item without admin or editor role.
     * @principle Role-based access control for inventory items.
     */
    match /inventory/{itemId} {
      allow get, list: if true;
      allow create: if isSignedIn() && (isAdmin() || isEditor());
      allow update: if isSignedIn() && (isAdmin() || isEditor()) && resource != null;
      allow delete: if isSignedIn() && (isAdmin() || isEditor()) && resource != null;
    }

    /**
     * @description Rules for the /sectors collection.
     * @path /sectors/{sectorId}
     * @allow (get, list) Public read access.
     * @allow (create) Only admins and editors can create new sectors.
     * @allow (update, delete) Only admins and editors can update or delete sectors.
     * @deny User attempts to create a sector without admin or editor role.
     * @principle Role-based access control for sectors.
     */
    match /sectors/{sectorId} {
      allow get, list: if true;
      allow create: if isSignedIn() && (isAdmin() || isEditor());
      allow update: if isSignedIn() && (isAdmin() || isEditor()) && resource != null;
      allow delete: if isSignedIn() && (isAdmin() || isEditor()) && resource != null;
    }

    /**
     * @description Rules for the /sectors/{sectorId}/machines collection.
     * @path /sectors/{sectorId}/machines/{machineId}
     * @allow (get, list) Public read access.
     * @allow (create) Only admins and editors can create new machines.
     * @allow (update, delete) Only admins and editors can update or delete machines.
     * @deny User attempts to create a machine without admin or editor role.
     * @principle Role-based access control for machines within sectors.
     */
    match /sectors/{sectorId}/machines/{machineId} {
      allow get, list: if true;
      allow create: if isSignedIn() && (isAdmin() || isEditor());
      allow update: if isSignedIn() && (isAdmin() || isEditor()) && resource != null;
      allow delete: if isSignedIn() && (isAdmin() || isEditor()) && resource != null;
    }

    /**
     * @description Rules for the /machineAssignments collection.
     * @path /machineAssignments/{assignmentId}
     * @allow (get, list) Public read access.
     * @allow (create) Only admins and editors can create new machine assignments.
     * @allow (update, delete) Only admins and editors can update or delete machine assignments.
     * @deny User attempts to create a machine assignment without admin or editor role.
     * @principle Role-based access control for machine assignments.
     */
    match /machineAssignments/{assignmentId} {
      allow get, list: if true;
      allow create: if isSignedIn() && (isAdmin() || isEditor());
      allow update: if isSignedIn() && (isAdmin() || isEditor()) && resource != null;
      allow delete: if isSignedIn() && (isAdmin() || isEditor()) && resource != null;
    }

    /**
     * @description Rules for the /usageLog collection.
     * @path /usageLog/{logId}
     * @allow (get, list) Public read access.
     * @allow (create) Only admins and editors can create new usage logs.
     * @allow (update, delete) Only admins and editors can update or delete usage logs.
     * @deny User attempts to create a usage log without admin or editor role.
     * @principle Role-based access control for usage logs.
     */
    match /usageLog/{logId} {
      allow get, list: if true;
      allow create: if isSignedIn() && (isAdmin() || isEditor());
      allow update: if isSignedIn() && (isAdmin() || isEditor()) && resource != null;
      allow delete: if isSignedIn() && (isAdmin() || isEditor()) && resource != null;
    }

    /**
     * @description Rules for the /users collection.
     * @path /users/{userId}
     * @allow (get) Any signed-in user can read a user profile.
     * @allow (create) A user can create their own profile (self-creation).
     * @allow (update, delete) Only the user themselves can update or delete their profile.
     * @deny User attempts to update or delete another user's profile.
     * @principle Enforces user-ownership for profile management.
     */
    match /users/{userId} {
      allow get: if isSignedIn();
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

        /**
     * @description Rules for the /roles collection.
     * @path /roles/{userId}
     * @allow (get) Any signed-in user can read their role.
     * @allow (create) Admins can create user roles
     * @allow (update, delete) Only admins can update or delete user roles.
     * @deny User attempts to update or delete another user's role.
     * @principle Enforces admin-ownership for role management.
     */
    match /roles/{userId} {
          allow get: if isSignedIn();
          allow list: if false;
          allow create: if isAdmin();
          allow update: if isAdmin() && resource != null;
          allow delete: if isAdmin() && resource != null;
        }
  }
}